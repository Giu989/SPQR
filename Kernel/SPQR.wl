(* ::Package:: *)

BeginPackage["SPQR`",{"FiniteFlow`","GeneralUtilities`"}];


(*SetUsage["FindIrreducibleMonomials[ideal$,vars$] finds the irreducible monomials of an ideal$ in the variables vars$ using a numerical Groebner Basis"]
(*needs a better description*)
SetUsage["BuildPolynomialSystem[targets$,ideal$,vars$,w$] builds and loads a system of linear equations to weight w$ into FiniteFlow to polynomially reduce the targets$ with respect to the ideal$"]*)


(*SetUsage["FindIrreducibleMonomials[ideal$,vars$] finds the irreducible monomials of an ideal$ in the variables vars$ using a numerical Groebner Basis"]*)


FindIrreducibleMonomials::usage = "FindIrreducibleMonomials[ideal,vars] Finds the irreducible monomials of an ideal in the variables vars using a numerical Groebner Basis.";
BuildPolynomialSystem::usage = "BuildPolynomialSystem[targets,ideal,vars,w] Builds and loads a system of linear equations to weight w into FiniteFlow to polynomially reduce the targets with respect to the ideal\n" <> "BuildPolynomialSystem[targets,ideal,vars,{wmin,wmax}] Increases the seed iteratively from wmin until the system closes or wmax is reached";
ReconstructPolynomialRemainder::usage = "ReconstructPolynomialRemainder[system] Reconstructs the remainder of a set of polynomials. system should be the output of BuildPolynomialSystem";
BuildCompanionMatrices::usage = "BuildCompanionMatrices[ideal,vars,w,irreds] Builds and loads a system of linear equations to weight w using the irreducible monomials irreds into FiniteFlow to generate the companion matrices for each of the vars in the ideal\n" <> "BuildCompanionMatrices[ideal,vars,{wmin,wmax},irreds] Increases the seed iteratively from wmin until the system closes or wmax is reached";
BuildTargetCompanionMatrices::usage = "BuildTargetCompanionMatrices[targets,cmatsystem] Builds companion matrices for given target polynomials. cmatsystem should be the output of BuildCompanionMatrices";
ReconstructTargetCompanionMatrices::usage = "ReconstructTargetCompanionMatrices[targetcmatsystem] Reconstructs the remainder of rational functions encoded in the companion matrices. targetcmatsystem should be the output of BuildTargetCompanionMatrices or BuildCompanionMatrices";
BuildCharacteristicPolynomials::usage = "BuildCharacteristicPolynomials[targetcmatsystem] Builds the characteristic polynomials for each companion matrix in targetcmatsystem\n" <> "BuildCharacteristicPolynomials[targetcmatsystem,indexlist] builds the characteristic polynomials of the matrices indexed in indexlist";
ReconstructCharacteristicPolynomials::usage = "ReconstructCharacteristicPolynomials[characteristicpolynomialsystem] reconstructs each coefficient of the characteristic polynomials produced by BuildCharacteristicPolynomials\n" <> "ReconstructCharacteristicPolynomials[characteristicpolynomialsystem,coefficientlist] reconstructs only the terms given in coefficientlist";
FFDet::usage = "FFDet[matrix] computes the determinant of a matrix using the Faddeev\[Dash]LeVerrier algorithm";
SortVariables::usage = "SortVariables[ideal,vars] Sorts variables in the list to try make Groebner Basis computations faster";
FindEliminationMonomials::usage = "FindEliminationMonomials[ideal,{x1,x2,...},{y1,y2,...}] computes the monomials appearing in the ideal where {x1,x2,..} have been eliminated using a numerical Groebner Basis.";
BuildEliminationSystems::usage = "BuildEliminationSystems[cmatsystem,monomials] Builds and loads the equations required to eliminate variables from an ideal. cmatsystem and monomials should be the outputs of BuildCompanionMatrices and FindEliminationMonomials respectively.";
ReconstructEliminationSystems::usage = "ReconstructEliminationSystems[elimSystem] reconstructs each coefficient of the eliminated ideal. elimSystem should be the output of BuildEliminationSystems.";
j::usage = " ";
extraparam::usage = " ";
targ::usage = " ";
SPQRGraph::usage = "SPQRGraph is the prefix used by all FiniteFlow graphs generated by SPQR";
(*m::usage = " ";*)


Begin["`Private`"]


With[{pac = PacletFind["SPQR"]},
  If[Length[pac] > 0,
    version = ("Version" //ReplaceAll[pac[[1]][[1]]]);
  ];
];


(*load in source code*)
Get[FileNameJoin[{DirectoryName[$InputFileName], "various_functions.m"}]];
Get[FileNameJoin[{DirectoryName[$InputFileName], "build_system.m"}]];
Get[FileNameJoin[{DirectoryName[$InputFileName], "construct_cmat.m"}]];
Get[FileNameJoin[{DirectoryName[$InputFileName], "construct_target_cmat.m"}]];
Get[FileNameJoin[{DirectoryName[$InputFileName], "eliminate_variables.m"}]];


(*check for updates, adapted from https://resources.wolframcloud.com/FunctionRepository/resources/GitHubInstall/*)
latestGitHubVersion[time_]:= Module[{ghAPI,imported,tag},
	ghAPI = StringTemplate @ "https://api.github.com/repos/`1`/`2`/releases/<* If[#3 =!= \"latest\", \"tags/\", \"\"] *>`3`";
	imported = CheckAbort[TimeConstrained[Import[ghAPI["giu989","SPQR","latest"], "RawJSON"],time,Return[$Failed]],Return[$Failed]]//Quiet;
	If[imported==$Failed,Return[$Failed];];
	tag = "tag_name"//ReplaceAll[imported];
	If[tag == "tag_name",Return[$Failed]];
	Return[StringTrim[tag,"v"]];
];
newVersionCheck[currentVersion_,testVersion_]:=Module[{currentVersionList,testVersionList},
	If[!StringQ[testVersion], Return[False]];
	currentVersionList = StringSplit[currentVersion,"."];
	testVersionList = StringSplit[testVersion,"."];
	Return[If[Sort[{testVersionList,currentVersionList}]!={testVersionList,currentVersionList},True,False]];
];

installDirectory = "Location"//ReplaceAll[PacletFind["SPQR"][[1]][[1]]];
fileDirectory = StringJoin[installDirectory,"/noupdate"];


If[!FileExistsQ[fileDirectory],gitVersion = CheckAbort[latestGitHubVersion[5],$Failed];];

If[!FileExistsQ[fileDirectory],
	If[newVersionCheck[version,gitVersion],
		Print["A new version is avaiable: ","v",gitVersion];
		updateString = StringJoin["Update to ", "v", ToString[gitVersion]];
		If[TrueQ@$Notebooks, 
			Print @ Button[updateString,ResourceFunction["GitHubInstall"]["giu989","SPQR"]; Print["Updated!"],Method -> "Queued"];
			Print @ Button["Do not ask again",If[!FileExistsQ[fileDirectory],CreateFile[fileDirectory]]; Print["Checking for updates disabled. To re-enable, delete the 'noupdate' file generated in the install directory: ", installDirectory],Method -> "Queued"];
		,
			Print["Update SPQR with: ", ResourceFunction["GitHubInstall"]["giu989","SPQR"]];
			Print["To disable autoupdate checking, add a file called \"noupdate\" to the install directory: ", installDirectory];
		];
	];
];


(*welcome message*)
If[TrueQ@$Notebooks,
	Print["SP\!\(\*TemplateBox[{},\n\"Rationals\"]\)R v" <> version <> ": Vsevolod Chestnov and Giulio Crisanti (2025)"]
,
	Print["SPQR v" <> version <> ": Vsevolod Chestnov and Giulio Crisanti (2025)"]
];
(*catch if Mathematica bugs and cannot find the documentation files*)
safeHelpLookup[p_]:=Module[{res},
	res=Quiet@Check[Documentation`ResolveLink[p],$Failed];
	If[res===$Failed||!StringQ[res],Print["Mathematica failed to link to the documentation. This is a Mathematica bug. Quitting the kernel and restarting the Mathematica application should fix this."];
	$Failed,Documentation`HelpLookup[p]]
];
(*documentation button*)
If[TrueQ@$Notebooks,
  Print @ Button["Open documentation",
    safeHelpLookup["paclet:SPQR/guide/SPQR"](*Documentation`HelpLookup["paclet:SPQR/guide/SPQR"]*),
    Method -> "Queued"
  ];
];


End[]


SetAttributes[
	{
		FindIrreducibleMonomials,BuildPolynomialSystem,ReconstructPolynomialRemainder,
		BuildCompanionMatrices,BuildTargetCompanionMatrices,ReconstructTargetCompanionMatrices,
		j,extraparam,targ,BuildCharacteristicPolynomials,ReconstructCharacteristicPolynomials,FFDet,
		SortVariables,FindEliminationMonomials,BuildEliminationSystems,ReconstructEliminationSystems
		,Nothing
	}
	, {(*Protected,*)ReadProtected}
];
(*Protect[{}];*)


EndPackage[]






